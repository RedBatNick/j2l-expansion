<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sEditorKid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>pos = 0;

//record movement values
grav = global.recordGrav;
xscale = global.recordXscale;
angle = global.recordAngle;
vspeed = global.recordVspeed;


//record transforms
dotkid = global.recordDotkid;
vkid = global.recordVkid;
telekid = global.recordTelekid;
lunarkid = global.recordLunarkid;
linekid = global.recordLinekid;


//record physics
infinitejump = global.recordInfinitejump;
icetype = global.recordIcetype;
slippage = global.recordSlippage;


//record border
borderbox = global.recordBorderbox;
screenwraptype = global.recordScreenwraptype;


//record interactions
dotclip = global.recordDotclip;
dotplatfix = global.recordDotplatfix;
telerange = global.recordTelerange;

global.PlayerFrameCounter = 0;


L = 0;
R = 0;
U = 0;
D = 0;

vineJump = 0;
releaseJump = 0;
pressLeft = 0;
pressRight = 0;
pressJump = 0;

FJ = 0; //TAS jump key
FK = 0; //TAS release key
FO = 0; //TAS vine release left
FP = 0; //TAS vine release right
FA = 0; //align left
FD = 0; //align right
FN = 0; //nudge left 
FM = 0; //nudge right
FU = 0; // 
FI = 0; //

image_alpha = 0.5;
jump = 8.5 * grav;
jump2 = 7 * grav;
maxSpeed = 3;
maxVspeed = 9;

if (linekid)
    image_angle = angle;

if (lunarkid) 
{
    //sl = instance_create(x, y, objBow);
    //sl.sprite_index = sprLander; 
    gravity = 0; 
    friction = 0.0005;
}
else { gravity = 0.4 * grav }

frozen = false;
djump = true;
onPlatform = false;
image_speed = 0.2;
nudgeBlockCheck = false;

slipSpeed = 0;
start = false;

warp = 0;

playerMask();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision
var killer = instance_place(x,y,oKiller);
if (killer != noone)
{
    with (killer) { highlight_count = 0; }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Edge of screen death

var xxL = x; 
var xxR = x; 
var yyU = y; 
var yyD = y;

switch(borderbox)
{
    case 0:
    xxL = x;
    xxR = x;
    yyU = y;
    yyD = y;
    break;

    case 1:
    xxL = bbox_right;
    xxR = bbox_left;
    yyU = bbox_bottom;
    yyD = bbox_top;
    break;
    
    case 2:
    xxL = bbox_left;
    xxR = bbox_right;
    yyU = bbox_top;
    yyD = bbox_bottom;
    break;
}

if (xxL &lt; 0 || xxR &gt; 800)
{
    if (screenwraptype != 1 &amp;&amp; screenwraptype != 3) 
    {
        if (xxL &lt; 0)
        {
            with (oBorderDeath)
            {
                if (type = 'left')
                    highlight_count = 0;
            }
        }
        else if (xxR &gt; 800)
        {
            with (oBorderDeath)
            {
                if (type = 'right')
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (xxL &lt; 0) { x += 800; }
        else if (xxR &gt; 800) { x -= 800; }
    }
}

if (yyU &lt; 0 || yyD &gt; 608)
{
    if (screenwraptype != 2 &amp;&amp; global.screenwraptype != 3) 
    {
        if (yyU &lt; 0)
        {
            with (oBorderDeath) 
            {
                if (type = 'top')
                    highlight_count = 0;
            }
        }
        else if (yyD &gt; 608)
        {
            with (oBorderDeath)
            {
                if (type = 'bottom')
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (yyU &lt; 0) { y += 608; }
        else if (yyD &gt; 608) { y -= 608; }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>adjustPlayerPosition_EndStep();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.frameaction_jump = false;
global.frameaction_djump = false;
global.frameaction_jumpslow = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// record load list

R = ds_list_find_value(global.recordList,pos);
pos++;
L = ds_list_find_value(global.recordList,pos);
pos++;
U = ds_list_find_value(global.recordList,pos);
pos++;
D = ds_list_find_value(global.recordList,pos);
pos++;
pressRight = ds_list_find_value(global.recordList,pos);
pos++;
pressLeft = ds_list_find_value(global.recordList,pos);
pos++;
vineJump = ds_list_find_value(global.recordList,pos);
pos++;
pressJump = ds_list_find_value(global.recordList,pos);
pos++;
releaseJump = ds_list_find_value(global.recordList,pos);
pos++;

FJ = ds_list_find_value(global.recordList,pos);
pos++;
FK = ds_list_find_value(global.recordList,pos);
pos++;
FP = ds_list_find_value(global.recordList,pos);
pos++;
FO = ds_list_find_value(global.recordList,pos);
pos++;

FA = ds_list_find_value(global.recordList,pos);
pos++;
FD = ds_list_find_value(global.recordList,pos);
pos++;
FU = ds_list_find_value(global.recordList,pos);
pos++;
FI = ds_list_find_value(global.recordList,pos);
pos++;
FN = ds_list_find_value(global.recordList,pos);
pos++;
FM = ds_list_find_value(global.recordList,pos);
pos++;

if (pos &gt;= ds_list_size(global.recordList)) {
    instance_destroy();
    instance_create(global.recordX,global.recordY,oRecordPlayer);
    reloadObjects();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// standard stuff

// position

// load control

global.PlayerFrameCounter += 1;

if (!lunarkid)
{
    h = 0;
    
    // Check for block underneath for nudging.
    var notOnBlock = (place_free(x, y + sign(grav)));
    
    if (global.checkNudgeEarly)
        nudgeBlockCheck = place_meeting(x,y+sign(grav),oBlock);
    else
        nudgeBlockCheck = false;
    
    //vine checks
    if (!global.linekid)
        xOff = 1;
    else
        xOff = 2;
    
    onVineL = (place_meeting(x-xOff,y,oVineL) &amp;&amp; notOnBlock);
    onVineR = (place_meeting(x+xOff,y,oVineR) &amp;&amp; notOnBlock);
        
    //gravity checks
    gravity = 0.4 * sign(grav);
    
    //speed checks
    if (icetype == 3)
        slippage = 0.07;
    else
        slippage = 0;
    
    if (icetype == 2) 
    {
        if (!instance_exists(oDomuIce))
            instance_create(x,y,oDomuIce);
    }
    else
    {
        if (instance_exists(oDomuIce))
            with (oDomuIce) { instance_destroy(); }
    }
    
    if (icetype == 1) { var block = oBlock; }
    else { var block = oSlipBlock; }
    
    with (block) { slip = 0.2; }
    var slipBlockTouching = instance_place(x,y+4*sign(grav),block);
    
    if (linekid) //LineKid functionality
    {   
        image_angle = angle;
    
        if ((FA || U) || (FD || D))
        {
            if (FA || U)
            {
                if (((angle &gt;= 0) &amp;&amp; (angle &lt; 90)) || ((angle &gt;= 180) &amp;&amp; (angle &lt; 270)))
                {
                    if (place_free((x - 2), y) || place_free((x + 2), y))
                    {
                        angle += 3;
                        
                        if ((angle &gt; 360) || (angle &lt; 0))
                        {
                            angle = ((angle + 360) % 360);
                        }
                    }
                }
                else if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                {
                    angle += 3;
                    
                    if ((angle &gt; 360) || (angle &lt; 0))
                    {
                        angle = ((angle + 360) % 360);
                    }
                }
            }
            if (FD || D)
            {
                if (((angle &gt; 0) &amp;&amp; (angle &lt;= 90)) || ((angle &gt; 180) &amp;&amp; (angle &lt;= 270)))
                {
                    if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                    {
                        angle -= 3;
                        
                        if ((angle &gt; 360) || (angle &lt; 0))
                        {
                            angle = ((angle + 360) % 360);
                        }
                    }
                }
                else if (place_free((x - 2), y) || place_free((x + 2), y))
                {
                    angle -= 3;
                    if ((angle &gt; 360) || (angle &lt; 0))
                    {
                        angle = ((angle + 360) % 360);
                    }
                }
            }
        }
        
        if (!notOnBlock)
        {
            if place_free(x, y)
            {
                testDist = 0;
                
                while (place_free(x, ((y + testDist) + 0.05)) &amp;&amp; (testDist &lt; 2))
                    testDist += 0.05;
                    
                if (testDist &lt; 2) { y += testDist; }
            }
        }
        
        firstMove = 0;
        lastMoveLast = 0;
        xBack = x; 
        yBack = y;
        
        blah = 0;
        if (true)//while ((!place_free(x, y)) || place_meeting(x, y, oBlock))
        {
            lastMove = 0;
            lineCollisionBlock = scrInstancePlaceList(x, y, oBlock);
            if (lineCollisionBlock != -4)
            {
                num = ds_list_size(lineCollisionBlock)
                for (i = 0; i &lt; num; i++)
                {
                    if (ds_list_find_value(lineCollisionBlock, i)).solid
                    {
                        testDistXpos = 0;
                        testDistYpos = 0;
                        testDistXneg = 0;
                        testDistYneg = 0;
                        
                        if (blah)
                        {
                            if (firstMove == 1) { testDistXpos = 99; }
                            else if (firstMove == 2) { testDistXneg = 99; }
                            else if (firstMove == 3) { testDistYpos = 99; }
                            else if (firstMove == 4) { testDistYneg = 99; }
                        }
                        
                        if (lastMove == 1) { testDistXneg = 99; }
                        else if (lastMove == 2) { testDistXpos = 99; }
                        else if (lastMove == 3) { testDistYneg = 99; }
                        else if (lastMove == 4) { testDistYpos = 99; }
                        
                        while (place_meeting((x + testDistXpos), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXpos &lt; 3))
                            testDistXpos += 0.2;
                            
                        while (place_meeting((x - testDistXneg), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXneg &lt; 3))
                            testDistXneg += 0.2;
                            
                        while (place_meeting(x, (y + testDistYpos), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYpos &lt; 3))
                            testDistYpos += 0.2;
                            
                        while (place_meeting(x, (y - testDistYneg), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYneg &lt; 3))
                            testDistYneg += 0.2;
                            
                        move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                        
                        if (move &lt; 3)
                        {
                            if (move == testDistXpos)
                            {
                                x += testDistXpos; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 1; }
                                lastMoveLast = lastMove; lastMove = 1;
                            }
                            else if (move == testDistXneg)
                            {
                                x -= testDistXneg; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 2; }
                                lastMoveLast = lastMove; lastMove = 2;
                            }
                            else if (move == testDistYpos)
                            {
                                y += testDistYpos; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 3; }
                                lastMoveLast = lastMove; lastMove = 3;
                            }
                            else if (move == testDistYneg)
                            {
                                y -= testDistYneg; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 4; }
                                lastMoveLast = lastMove; lastMove = 4;
                            }
                        }
                        else
                        {
                            x = xBack; y = yBack;
                            yprevious = yBack; xprevious = xBack;
                            lastMove = lastMoveLast;
                        }
                    }
                }
                if (!place_free(x, y))
                {
                    testDistXpos = 0;
                    testDistYpos = 0;
                    testDistXneg = 0;
                    testDistYneg = 0;
                    
                    while ((!place_free((x + testDistXpos), y)) &amp;&amp; (testDistXpos &lt; 3))
                        testDistXpos += 0.2;
                        
                    while ((!place_free((x - testDistXneg), y)) &amp;&amp; (testDistXneg &lt; 3))
                        testDistXneg += 0.2;
                        
                    while ((!place_free(x, (y + testDistYpos))) &amp;&amp; (testDistYpos &lt; 3))
                        testDistYpos += 0.2;
                        
                    while ((!place_free(x, (y - testDistYneg))) &amp;&amp; (testDistYneg &lt; 3))
                        testDistYneg += 0.2;
                        
                    move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                    
                    if (move == testDistXpos)
                    {
                        x += testDistXpos; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 1; }
                        lastMoveLast = lastMove; lastMove = 1;
                    }
                    else if (move == testDistXneg)
                    {
                        x -= testDistXneg; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 2; }
                        lastMoveLast = lastMove; lastMove = 2;
                    }
                    else if (move == testDistYpos)
                    {
                        y += testDistYpos; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 3; }
                        lastMoveLast = lastMove; lastMove = 3;
                    }
                    else if (move == testDistYneg)
                    {
                        y -= testDistYneg; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 4; }
                        lastMoveLast = lastMove; lastMove = 4;
                    }
                }
            }
            blah = 1;
        }
    }
    else
    {
        if (!lunarkid)
        {
            if (image_angle != 0) { image_angle = 0; }
        }
    }
    
    // moving
    var h = R;
    if (h == 0) { h = -L; }
    if (frozen) { h = 0; }
    
    if (h != 0) 
    {
        if (!onVineR &amp;&amp; !onVineL)
            xscale = h;

        if (h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL) 
        {
            if (slippage != 0)   //player momentum, aka "CBT Ice"
            {
                hspeed += slippage * h;
                    
                if (abs(hspeed) &gt; maxSpeed)
                    hspeed = maxSpeed * h;
            }
            else if (slipBlockTouching == noone) 
            {
                hspeed = maxSpeed * h;
            }
            else 
            {
                if (h == 1 &amp;&amp; hspeed &lt; maxSpeed) || (h == -1 &amp;&amp; hspeed &gt; -maxSpeed) 
                    hspeed += slipBlockTouching.slip * h;
            }
            playerSprite(sPlayerRunning);
            image_speed = 0.5;
        }
    }
    else // not moving
    {
        if (slippage != 0)
        {
            if (abs(hspeed) &gt; maxSpeed) { hspeed = maxSpeed * (sign(hspeed)); }
            if (hspeed &gt; 0)
            {
                hspeed -= (slippage / 2);
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0)
            {
                hspeed += (slippage / 2);
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        else if (slipBlockTouching == noone) 
        {
            hspeed = 0;
        }
        else 
        {
            if (hspeed &gt; 0) 
            {
                hspeed -= slipBlockTouching.slip;
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0) 
            {
                hspeed += slipBlockTouching.slip;
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        playerSprite(sPlayerIdle);
        image_speed = 0.2;
    }
    
    if (!onPlatform) // set jump/fall sprite
    {
        if (vspeed*sign(grav) &lt; -0.05) { playerSprite(sPlayerJump); }
        else if (vspeed*sign(grav) &gt; 0.05) { playerSprite(sPlayerFall); }
    }
    else // fall off platform
    {
        if (!place_meeting(x,y+4*sign(grav),oPlatform)) { onPlatform = false; }
    }
    
    // slide block
    var slideBlockTouchingH = instance_place(x, y + sign(grav), oSlideBlock);
    var slideBlockTouchingV = instance_place(x + global.player_xscale, y, oSlideBlock);
    
    if (slideBlockTouchingH != noone || slideBlockTouchingV != noone) //on a slide block, start moving with it
    {
        if (slideBlockTouchingH != noone) //moving horizontally (conveyor)
            hspeed += slideBlockTouchingH.h; 
            
        if (slideBlockTouchingV != noone) //moving vertically (elevator)
        {
            vspeed += slideBlockTouchingV.v;
            
            if (!place_meeting(x, y-(vspeed*sign(grav)),oBlock))
            {
                if (vspeed * sign(grav) &lt;= 0) { playerSprite(sPlayerJump); }
                else if (vspeed * sign(grav) &gt; 0) { playerSprite(sPlayerFall); }
            }
        }
    }
    
    // terminal velocity
    if (abs(vspeed) &gt; maxVspeed)
        vspeed = sign(vspeed)*maxVspeed;

    // jump, shoot
          
    //if (pressShoot) playerShoot();
    if (pressJump) 
        playerJump();
    if (releaseJump) 
        playerVJump();
    
    if (FJ) { playerJump(); }
    if (FK) { playerVJump(); }
}
else
{
    if (!frozen) //Lunar Lander, aka "Rocket"
    {
        if (pressJump &amp;&amp; vkid) { playerJump(); }
        
        if (start)
        { 
            //if (instance_exists(objBow)) { instance_destroy(objBow); } 
        }
    
        if ((gravity == 0) &amp;&amp; (L || (R || (U || D))))
        {
            start = true;
            gravity = 0.008;
        }
        
        if (U) { motion_add((image_angle + 90), 0.013); }
        if (L) { image_angle += 1; }
        else if (R) { image_angle -= 1; }
         
        if (image_angle &gt; 360 || image_angle &lt; 0)
            image_angle = ((image_angle + 360) % 360);
        
        playerAngle = image_angle;
        playerSprite(sLunarkid);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vines

if (!linekid)
    var xOff = 1;
else
    var xOff = 2;
    
var onVineL = (place_meeting(x-xOff,y,oVineL))// &amp;&amp; notOnBlock);
var onVineR = (place_meeting(x+xOff,y,oVineR))// &amp;&amp; notOnBlock);

if (onVineL || onVineR) 
{
    if (onVineR) 
        xscale = -1;
    else 
        xscale = 1;
    
    vspeed = 2*grav;
    
    playerSprite(sPlayerSliding);
    image_speed = 0.5;
    
    // pressed away from the vine
    if (onVineL &amp;&amp; pressRight || FP) 
    || (onVineR &amp;&amp; pressLeft || FO) 
    {
        if (vineJump) // jumping off vine
        {
            if (onVineR) 
                hspeed = -15;
            else 
                hspeed = 15;
                
            vspeed = -9 * grav;
            
            audio_play_sound(sndWallJump,0,0);
            playerSprite(sPlayerJump);
        }
        else // walking off vine
        {
            if (onVineR) 
                hspeed = -3;
            else 
                hspeed = 3;
                
            playerSprite(sPlayerFall);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slopes 

if (instance_exists(oSlope) &amp;&amp; hspeed != 0)
{
    var moveLimit = abs(hspeed);   //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed, y+vspeed+gravity, oSlope) &amp;&amp; (vspeed+gravity)*grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x, y+vspeed))
        {
            if (grav == 1)    //Normal
                move_contact_solid(270, abs(vspeed));
            else    //Flipped
                move_contact_solid(90, abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x, y + grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //Did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //Moving down a slope
    if (!notOnBlock)
    {                                              
        var onSlope = (place_meeting(x, y + grav, oSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //Check how far we should move down
            while ((!place_meeting(x + hTest, y - ySlope + grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + grav))) &amp;&amp; (ySlope*grav &gt; -floor(moveLimit * (hTest/hspeed))))
            {
                ySlope -= grav;
            }
            
            //Check if we actually need to move down
            if (place_meeting(x + hTest, y - ySlope + grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + grav)))
            {
                if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //Moving up a slope
    if (place_meeting(x + hspeed, y, oSlope))
    {                                           
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //Check how far we have to move up
            while ( place_meeting(x + hTest, y - ySlope, oSlope) &amp;&amp; (ySlope*grav &lt; floor(moveLimit * (hTest/hspeed))) )
            {
                ySlope += grav;
            }                                                 
            
            //Check if we actually need to move up
            if (place_free(x + hTest, y - ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //Set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}                 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var pd = 2, py = 9, phy = 1, pyc = 8;

if (dotkid)
{
    if (dotplatfix) 
    { 
        pd = 1;
        py = 1;
        pyc = 0;
        phy = 1;
    }
}

if (lunarkid || other.image_alpha &lt; 1) 
    exit;

if (sign(grav) == 1) 
{
    if (y-vspeed/pd &lt;= other.y) // touching platform
    {
        if (other.vspeed &gt;= 0) // snap to platform
        {
            y = other.y-py;
            vspeed = other.vspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
else if (sign(grav) == -1)
{
    if (y-vspeed/pd &gt;= other.y+other.sprite_height-pyc) // touching platform
    {
        if (other.yspeed &lt;= 0) // snap to platform
        {
            y = other.y+other.sprite_height+phy;
            vspeed = other.yspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// push against blocks horizontally
if (!lunarkid)
{
    if (!place_free(x+hspeed,y)) 
    {
        if (sign(grav) == 1) 
        {
            var dir;
            if (hspeed &lt;= 0) { dir = 180; }
            if (hspeed &gt; 0) { dir = 0; }
            move_contact_solid(dir, abs(hspeed));
        }
        else 
        {
            var dir;
            if (hspeed &lt; 0) { dir = 180; }
            if (hspeed &gt;= 0) { dir = 0; }
            move_contact_solid(dir, abs(hspeed));
        }
        hspeed = 0;
    }
    
    // push against blocks vertically
    if (!place_free(x,y+vspeed))
    {
        if (sign(grav) == 1) 
        {
            var dir;
            if (vspeed &lt;= 0) { dir = 90; }
            if (vspeed &gt; 0) { dir = 270; djump = true; }
            move_contact_solid(dir, abs(vspeed));
        }
        else 
        {
            var dir;
            if (vspeed &lt;= 0) { dir = 90; djump = true; }
            if (vspeed &gt; 0) { dir = 270; }
            move_contact_solid(dir, abs(vspeed));
        }
        vspeed = 0;
    }
    
    if (!place_free(x+hspeed,y+vspeed))
        hspeed = 0;
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var drawX = x, drawY = y, pCol = c_white;

var xScale = xscale;
var yScale = grav;
 
if (!vkid) 
{
    if (!infinitejump) 
    { 
        if (!dotkid) { pCol = c_white; }
        else 
        { 
            if (telekid) { pCol = c_white; }
            else { pCol = c_red; }
        }
    }
    else { pCol = c_blue; }
}
if (vkid = 1) { pCol = make_color_rgb(1,164,217); }
else if (vkid = 2) { pCol = make_color_rgb(164,1,171); }

if (!dotkid &amp;&amp; !linekid &amp;&amp; !lunarkid)
{
    if (grav == -1) { drawY += 1; }
    xScale = xscale;
    yScale = grav;
}
else
{
    xScale = image_xscale;
    yScale = image_yscale;
    
    if (global.showhitbox != 0)
        pCol = c_fuchsia;
}

if (global.showhitbox != 2) 
{
    if (!vkid &amp;&amp; !telekid) 
    {
        draw_sprite_ext(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha);
    } 
    else 
    {
        draw_sprite_fog(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha,pCol);
    }
}
if (global.showhitbox != 0) 
{
    draw_sprite_ext(mask_index,0,x,y,
    image_xscale,image_yscale,image_angle,pCol,(0.5*global.showhitbox));
}

if (mask_index = sDotkid &amp;&amp; global.dotkidoutline)
    draw_sprite_ext(sDotkidOutline,0,x,y,1,1,image_angle,pCol,1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
