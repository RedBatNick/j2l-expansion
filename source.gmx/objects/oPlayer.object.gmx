<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sEditorKid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///create
global.tasAD = false; //sets whether TAS mode input is active


jump = 8.5 * sign(global.grav); //sets the primary jump speed
jump2 = 7 * sign(global.grav); //sets the secondary jump speed
maxSpeed = 3; //sets the max relative horizontal speed
maxVspeed = 9; //sets the max relative vertical speed

if (global.linekid) {
    image_angle = global.savePlayerAngle; //sets linekid's image angle
}
    
if (global.lunarkid) {
    //sl = instance_create(x, y, objBow);
    //sl.sprite_index = sprLander; 
    
    gravity = 0; //sets lunarkid to spawn inert 
    friction = 0.0005;
}
else { 
    gravity = 0.4 * sign(global.grav); //sets the player's constant falling speed
}
start = false; //sets whether lunarkid is in motion


frozen = false; //sets whether the player is unable to move
numJumps = 2; //sets the maximum number of jumps the player has
djump = numJumps-1; //sets whether the player has a secondary jump
onPlatform = false; //sets whether the player is on a platform
image_speed = 0.2; //sets the animation speed of the player's idle animation
nudgeBlockCheck = false; //sets whether the player is standing on a block


//ladder variables
onLadder = false; //sets if player climbs onto a ladder
ladderJump = false; //sets if player jumps off a ladder
ladderV = false; //sets if player is moving up/down a ladder
ladderH = false; //sets if player is movuing left/right on a ladder


//gravity variables
lowGrav = false; //low-gravity for the player
highGrav = false; //high-gravity for the player
zeroGrav = false; //zero-gravity for the player
antiGrav = false; //anti-gravity for the player


//speed variables
lowSpeed = false; //slow-speed for the player
highSpeed = false; //high-speed for the player
autoSpeed = false; //auto-run for the player
buffSpeed = false; //buffer-run for the player


//vine variables
vineJump = 0; //sets if player is interacting with a red vine
vineSlip = 0; //sets if player is interacting with an ice vine / pressure vine
vineStick = 0; //sets if player is interacting with a sticky vine
vineLowGrav = 0; //sets if player is interacting with a low gravity vine
vineZeroGrav = 0; //sets if player is interacting with a zero gravity vine
vineSpeed = 0; //sets if player is interacting with a fire vine / plasma vine
//vineOsc = 0; //sets if player is interacting with a mercury vine
vineAuto = 0; //sets if player is interacting with an auto vine
vineBuff = 0; //sets if player is interacting with a buffer vine

lowGravVine = false; //secondary variable for vineGrav to tell if you should have low-grav
highGravVine = false; //secondary variable for vineGrav to tell if you should have high-grav
noGravVine = false; //secondary variable for vineGrav to tell if you should have no-grav
antiGravVine = false; //secondary variable for vineGrav to tell if you should have anti-grav
//speedOsc = 0; //the current speed the player is oscillating with the vineOsc effect


//Jumple Refrenture variables
highd = 0; //sets whether the player has a high double jump 
lowd = 0; //sets whether the player has a low double jump 
flipd = 0; //sets whether the player's double jump will flip gravity 
teled = 0; //sets whether the player's double jump will teleport forward
fastd = 0; //sets whether the player has a fast double jump
switchd = 0; //sets whether the player's double jump will switch toggle objects
slowd = 0; //sets whether the player's double jump will slow time


//other variables
slipSpeed = 0; //sets whether the player has Domu ice effect active (DOMU)


hit = 0; //sets whether the kid is intangible or not
hitX = x; //sets the x position of the player's hit X coordinate
hitY = y; //sets the y position of the player's hit X coordinate

playerSprite(sPlayerIdle);
dynamicCollision(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resolve collisions between step and now, collide with dynamic blocks

/*if (!place_free(x, y))
{
    var dirX = sign(x-xsafe);
    var dirY = sign(y-ysafe);
    var epsilon = 0.001; //Appease the floating point gods
    
    //If something moved the player into a block since Step, move back towards where we were until we're out of a block.
    while(!place_free(x, y))
    {
        if (dirX * (x - xsafe) &gt;= epsilon)
        {
            x -= sign(x-xsafe) * min( abs(x-xsafe), 1 );
        }
        else if (dirY * (y - ysafe) &gt;= epsilon)
        {
            y -= sign(y-ysafe) * min( abs(y-ysafe), 1 );
        }
        else break;
    }
}

if (global.blocksCrush)
{
    dynamicCollision(false, killPlayer);
}
else
{
    dynamicCollision(false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision
var killer = instance_place(x,y,oKiller);
if (killer != noone)
{
    killPlayer();
    with (killer) { highlight_count = 0; }
}

//Control how long the player is intangible after being hit while god mode is active
if (hit != 0) 
{ 
    image_alpha = 0.7;
    hit -= 1; 
}
else { image_alpha = 1; }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Edge of screen death

var xxL = x; 
var xxR = x; 
var yyU = y; 
var yyD = y;

switch(global.borderbox)
{
    case bboxtype_center:
    xxL = x;
    xxR = x;
    yyU = y;
    yyD = y;
    break;

    case bboxtype_far:
    xxL = bbox_right;
    xxR = bbox_left;
    yyU = bbox_bottom;
    yyD = bbox_top;
    break;
    
    case bboxtype_near:
    xxL = bbox_left;
    xxR = bbox_right;
    yyU = bbox_top;
    yyD = bbox_bottom;
    break;
}

if (xxL &lt; 0 || xxR &gt; 800)
{
    if (global.screenwraptype != wraptype_h &amp;&amp; global.screenwraptype != wraptype_both) 
    {
        if (global.deathEnabled) { killPlayer(); }
        if (xxL &lt; 0)
        {
            with (oBorderDeath)
            {
                if (type = "left")
                    highlight_count = 0;
            }
        }
        else if (xxR &gt; 800)
        {
            with (oBorderDeath)
            {
                if (type = "right")
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (xxL &lt; 0) { x += 800; }
        else if (xxR &gt; 800) { x -= 800; }
    }
}

if (yyU &lt; 0 || yyD &gt; 608)
{
    if (global.screenwraptype != wraptype_v &amp;&amp; global.screenwraptype != wraptype_both) 
    {
        if (global.deathEnabled) { killPlayer(); }
        
        if (yyU &lt; 0)
        {
            with (oBorderDeath) 
            {
                if (type = "top")
                    highlight_count = 0;
            }
        }
        else if (yyD &gt; 608)
        {
            with (oBorderDeath)
            {
                if (type = "bottom")
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (yyU &lt; 0) { y += 608; }
        else if (yyD &gt; 608) { y -= 608; }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player animations
ladderJump = false;

if (onLadder)
{
    playerSprite(sPlayerClimbBack);
    image_speed = 0.1;
}
    
if (ladderV)
{
    playerSprite(sPlayerClimbVer);
    image_speed = 0.2;
}
else if (ladderH)
{
    playerSprite(sPlayerClimbHor);
    image_speed = 0.2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///jump actions
global.frameaction_jump = false;
global.frameaction_djump = false;
global.frameaction_jumpslow = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///record add list
if (global.record == 1) 
{
    //#1
    ds_list_add(global.recordList,scrButtonCheck(KEY.RIGHT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.LEFT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.UP));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.DOWN));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.RIGHT));
     
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.LEFT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.JUMP));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.JUMP));
    
    ds_list_add(global.recordList,scrButtonCheckReleased(KEY.JUMP));
    
    //#2
    ds_list_add(global.recordList,keyboard_check(ord('J')));
    
    ds_list_add(global.recordList,keyboard_check(ord('K')));
    
    ds_list_add(global.recordList,keyboard_check(ord('P')));
    
    ds_list_add(global.recordList,keyboard_check(ord('O')));
    
    //#3
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.ALIGN_LEFT));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.ALIGN_RIGHT));
    
    ds_list_add(global.recordList,keyboard_check(ord('U')));
    
    ds_list_add(global.recordList,keyboard_check(ord('I')));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.NUDGE_LEFT));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.NUDGE_RIGHT));

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player actions and movement
var L = scrButtonCheck(KEY.LEFT,1);
var R = scrButtonCheck(KEY.RIGHT,1);
var U = scrButtonCheck(KEY.UP);
var D = scrButtonCheck(KEY.DOWN);


if (!global.recordingpaused &amp;&amp; !instance_exists(oRecordPlayer))
    global.PlayerFrameCounter += 1;

if (!global.lunarkid) 
{
    if (!vineAuto &amp;&amp; !place_meeting(x, y, oFieldAutoSpeed) &amp;&amp; !autoSpeed)
    {
        h = 0; 
        
        if (global.invertcontrols)
        {
            if (!vineBuff &amp;&amp; !place_meeting(x, y, oFieldBuffSpeed) &amp;&amp; !buffSpeed)
            {
                right = (scrButtonCheck(KEY.LEFT,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
                left = (scrButtonCheck(KEY.RIGHT,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
            }
            else
            {
                right = scrButtonCheckPressed(KEY.LEFT);
                left = scrButtonCheckPressed(KEY.RIGHT);
            }
        }
        else
        {
            if (!vineBuff &amp;&amp; !place_meeting(x, y, oFieldBuffSpeed) &amp;&amp; !buffSpeed)
            {
                left = (scrButtonCheck(KEY.LEFT,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
                right = (scrButtonCheck(KEY.RIGHT,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
            }
            else
            {
                left = scrButtonCheckPressed(KEY.LEFT);
                right = scrButtonCheckPressed(KEY.RIGHT);
            }
        }
        
        var L = left;
        var R = right;
        var U = (scrButtonCheck(KEY.UP,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.upButton)));
        var D = (scrButtonCheck(KEY.RIGHT,1));// || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.downButton)));
    }
    else if (vineAuto || place_meeting(x, y, oFieldAutoSpeed) || autoSpeed)
    {
        L = noone; 
        R = noone;
        h = sign(global.player_xscale); 
        hspeed = h * maxSpeed; 
    }
    
    // Check for block underneath for nudging.
    var notOnBlock = (place_free(x, y+global.grav));
    
    if (global.checkNudgeEarly)
        nudgeBlockCheck = place_meeting(x,y+global.grav,oBlock);
    else
        nudgeBlockCheck = false;

    //vine checks
    if (!global.linekid)
        vOff = 1;
    else
        vOff = 2;
    
    var notOnBlock = (place_free(x, y + sign(global.grav)));
    
    //var onVineD = vineCheck(x, y+vOff, oVineD, notOnBlock);
    var onVineL = vineCheck(x+vOff, y, oVineL, notOnBlock);
    var onVineR = vineCheck(x-vOff, y, oVineR, notOnBlock);
    //var onVineU = vineCheck(x, y-vOff, oVineU, notOnBlock);    
    if (global.jtoolphysics) {
        onVineD = distance_to_object(oVineD) &lt;= 1 &amp;&amp; place_free(x+sign(global.grav),y);
        onVineL = distance_to_object(oVineL) &lt;= 1 &amp;&amp; place_free(x,y+sign(global.grav));
        onVineR = distance_to_object(oVineR) &lt;= 1 &amp;&amp; place_free(x,y+sign(global.grav));
        onVineU = distance_to_object(oVineU) &lt;= 1 &amp;&amp; place_free(x+sign(global.grav),y);
    }
    
    var vineL = noone;     
    if (onVineL) { vineL = instance_place(x+vOff, y, oVineL); }
    
    var vineR = noone; 
    if (onVineR) { vineR = instance_place(x-vOff, y, oVineR); }

    /*
    onVineD = (place_meeting(x,y+vOff,oVineD) &amp;&amp; notOnBlock);
    onVineL = (place_meeting(x+vOff,y,oVineL) &amp;&amp; notOnBlock);
    onVineR = (place_meeting(x-vOff,y,oVineR) &amp;&amp; notOnBlock);
    onVineU = (place_meeting(x,y-vOff,oVineU) &amp;&amp; notOnBlock);
    */
        
    //jump checks
    if (highd = 1) { 
        jump2 = (12 * sign(global.grav)); 
    }
    
    if (lowd = 1) { 
        jump2 = (5 * sign(global.grav)); 
    }
    
    if (highd != 1 &amp;&amp; lowd != 1) { 
        jump2 = (7 * sign(global.grav)); 
    }
    
    if (!place_free(x,y+global.grav) || onPlatform) 
    {
        highd = 0;
        lowd = 0;
        flipd = 0;
        teled = 0;
        fastd = 0;
        switchd = 0;
        slowd = 0;

        if (instance_exists(oSlowJumpEffect))
            with (oSlowJumpEffect) { instance_destroy(); }
    }
    
    //gravity checks
    if (!onLadder)
    {
        gravity = 0.4 * sign(global.grav);
    
        if (place_meeting(x, y, oFieldHighGrav) || highGrav == true) {
            gravity = 0.7 * sign(global.grav);
        } else if (place_meeting(x, y, oFieldLowGrav) || lowGrav == true) {
            gravity = 0.2 * sign(global.grav);
        } else if (place_meeting(x, y, oFieldZeroGrav) || zeroGrav || vineZeroGrav) {
            gravity = 0;
        } else if (place_meeting(x, y, oFieldAntiGrav) || antiGrav == true) { 
            gravity = -0.4 * sign(-global.grav);
        } else if (vineStick) {
            gravity = 0;
            vineStick = false; 
        } else if (vineLowGrav) {
            gravity = 0.3 * sign(global.grav);
        }
        
        if (abs(global.grav) == 1) { gravity_direction = 270; }
        else if (abs(global.grav) == 2) { gravity_direction = 0; }
    }
    
    //speed checks
    if (!vineSpeed) {// &amp;&amp; !instance_exists(objYoshiControl) {
        maxSpeed = 3;
        
        if (place_meeting(x, y, oFieldLowSpeed)) {
            maxSpeed = 1;
        } else if (place_meeting(x, y, oFieldHighSpeed) || highSpeed = true) {
            maxSpeed = 6;
        }
    }
    
    //ice checks
    if (global.icetype == icetype_pressure)
        global.slippage = 0.07;
    else
        global.slippage = 0;
    
    if (global.icetype == icetype_domu) 
    {
        if (!instance_exists(oDomuIce))
            instance_create(x,y,oDomuIce);
    }
    else
    {
        if (instance_exists(oDomuIce))
            with (oDomuIce) { instance_destroy(); }
    }
    
    if (global.icetype == icetype_slip) { var block = oBlock; }
    else { var block = oSlipBlock; }
    
    with (block) { slip = 0.2; }
    var slipBlockTouching = instance_place(x,y+4*global.grav,block);
    
    if (global.linekid) //LineKid functionality
    {   
        image_angle = global.playerAngle;
    
        if ((scrButtonCheck(KEY.ALIGN_LEFT) || U) || (scrButtonCheck(KEY.ALIGN_RIGHT) || D))
        {
            if (scrButtonCheck(KEY.ALIGN_LEFT) || U)
            {
                if (((global.playerAngle &gt;= 0) &amp;&amp; (global.playerAngle &lt; 90)) || ((global.playerAngle &gt;= 180) &amp;&amp; (global.playerAngle &lt; 270)))
                {
                    if (place_free((x - 2), y) || place_free((x + 2), y))
                    {
                        global.playerAngle += 3;
                        
                        if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                        {
                            global.playerAngle = ((global.playerAngle + 360) % 360);
                        }
                    }
                }
                else if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                {
                    global.playerAngle += 3;
                    
                    if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                    {
                        global.playerAngle = ((global.playerAngle + 360) % 360);
                    }
                }
            }
            if (scrButtonCheck(KEY.ALIGN_RIGHT) || D)
            {
                if (((global.playerAngle &gt; 0) &amp;&amp; (global.playerAngle &lt;= 90)) || ((global.playerAngle &gt; 180) &amp;&amp; (global.playerAngle &lt;= 270)))
                {
                    if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                    {
                        global.playerAngle -= 3;
                        
                        if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                        {
                            global.playerAngle = ((global.playerAngle + 360) % 360);
                        }
                    }
                }
                else if (place_free((x - 2), y) || place_free((x + 2), y))
                {
                    global.playerAngle -= 3;
                    if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                    {
                        global.playerAngle = ((global.playerAngle + 360) % 360);
                    }
                }
            }
        }
        
        if (!notOnBlock)
        {
            if place_free(x, y)
            {
                testDist = 0;
                
                while (place_free(x, ((y + testDist) + 0.05)) &amp;&amp; (testDist &lt; 2))
                    testDist += 0.05;
                    
                if (testDist &lt; 2) { y += testDist; }
            }
        }
        
        firstMove = 0;
        lastMoveLast = 0;
        xBack = x; 
        yBack = y;
        
        blah = 0;
        if (true)//while ((!place_free(x, y)) || place_meeting(x, y, oBlock))
        {
            lastMove = 0;
            lineCollisionBlock = scrInstancePlaceList(x, y, oBlock);
            if (lineCollisionBlock != -4)
            {
                num = ds_list_size(lineCollisionBlock);
                for (i = 0; i &lt; num; i++)
                {
                    if (ds_list_find_value(lineCollisionBlock, i)).solid
                    {
                        testDistXpos = 0;
                        testDistYpos = 0;
                        testDistXneg = 0;
                        testDistYneg = 0;
                        
                        if (blah)
                        {
                            if (firstMove == 1) { testDistXpos = 99; }
                            else if (firstMove == 2) { testDistXneg = 99; }
                            else if (firstMove == 3) { testDistYpos = 99; }
                            else if (firstMove == 4) { testDistYneg = 99; }
                        }
                        
                        if (lastMove == 1) { testDistXneg = 99; }
                        else if (lastMove == 2) { testDistXpos = 99; }
                        else if (lastMove == 3) { testDistYneg = 99; }
                        else if (lastMove == 4) { testDistYpos = 99; }
                        
                        while (place_meeting((x + testDistXpos), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXpos &lt; 3))
                            testDistXpos += 0.2;
                            
                        while (place_meeting((x - testDistXneg), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXneg &lt; 3))
                            testDistXneg += 0.2;
                            
                        while (place_meeting(x, (y + testDistYpos), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYpos &lt; 3))
                            testDistYpos += 0.2;
                            
                        while (place_meeting(x, (y - testDistYneg), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYneg &lt; 3))
                            testDistYneg += 0.2;
                            
                        move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                        
                        if (move &lt; 3)
                        {
                            if (move == testDistXpos)
                            {
                                x += testDistXpos; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 1; }
                                lastMoveLast = lastMove; lastMove = 1;
                            }
                            else if (move == testDistXneg)
                            {
                                x -= testDistXneg; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 2; }
                                lastMoveLast = lastMove; lastMove = 2;
                            }
                            else if (move == testDistYpos)
                            {
                                y += testDistYpos; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 3; }
                                lastMoveLast = lastMove; lastMove = 3;
                            }
                            else if (move == testDistYneg)
                            {
                                y -= testDistYneg; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 4; }
                                lastMoveLast = lastMove; lastMove = 4;
                            }
                        }
                        else
                        {
                            x = xBack; y = yBack;
                            yprevious = yBack; xprevious = xBack;
                            lastMove = lastMoveLast;
                        }
                    }
                }
                if (!place_free(x, y))
                {
                    testDistXpos = 0;
                    testDistYpos = 0;
                    testDistXneg = 0;
                    testDistYneg = 0;
                    
                    while ((!place_free((x + testDistXpos), y)) &amp;&amp; (testDistXpos &lt; 3))
                        testDistXpos += 0.2;
                        
                    while ((!place_free((x - testDistXneg), y)) &amp;&amp; (testDistXneg &lt; 3))
                        testDistXneg += 0.2;
                        
                    while ((!place_free(x, (y + testDistYpos))) &amp;&amp; (testDistYpos &lt; 3))
                        testDistYpos += 0.2;
                        
                    while ((!place_free(x, (y - testDistYneg))) &amp;&amp; (testDistYneg &lt; 3))
                        testDistYneg += 0.2;
                        
                    move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                    
                    if (move == testDistXpos)
                    {
                        x += testDistXpos; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 1; }
                        lastMoveLast = lastMove; lastMove = 1;
                    }
                    else if (move == testDistXneg)
                    {
                        x -= testDistXneg; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 2; }
                        lastMoveLast = lastMove; lastMove = 2;
                    }
                    else if (move == testDistYpos)
                    {
                        y += testDistYpos; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 3; }
                        lastMoveLast = lastMove; lastMove = 3;
                    }
                    else if (move == testDistYneg)
                    {
                        y -= testDistYneg; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 4; }
                        lastMoveLast = lastMove; lastMove = 4;
                    }
                }
            }
            blah = 1;
        }
    }
    else
    {
        if (!global.lunarkid)
        {
            if (image_angle != 0) { image_angle = 0; }
        }
    }
    
    // moving
    if (!frozen)
    {
        if (R)
            h = 1;
        else if (L)
            h = -1;
    }
    else { h = 0; }
    
    if (h != 0) 
    {
        if (!onVineR &amp;&amp; !onVineL)
            global.player_xscale = h;

        if (h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL) 
        {
            if (global.slippage != 0)   //player momentum, aka "CBT Ice"
            {
                hspeed += global.slippage * h;
                    
                if (abs(hspeed) &gt; maxSpeed)
                    hspeed = maxSpeed * h;
            }
            else if (slipBlockTouching == noone) 
            {
                hspeed = maxSpeed * h;
            }
            else 
            {
                if (h == 1 &amp;&amp; hspeed &lt; maxSpeed) || (h == -1 &amp;&amp; hspeed &gt; -maxSpeed) 
                    hspeed += slipBlockTouching.slip * h;
            }
            playerSprite(sPlayerRunning);
            image_speed = 0.5;
        }
    }
    else // not moving
    {
        if (global.slippage != 0)
        {
            if (abs(hspeed) &gt; maxSpeed) { hspeed = maxSpeed * ((hspeed)); }
            if (hspeed &gt; 0)
            {
                hspeed -= (global.slippage / 2);
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0)
            {
                hspeed += (global.slippage / 2);
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        else if (slipBlockTouching == noone) 
        {
            hspeed = 0;
        }
        else 
        {
            if (hspeed &gt; 0) 
            {
                hspeed -= slipBlockTouching.slip;
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0) 
            {
                hspeed += slipBlockTouching.slip;
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        playerSprite(sPlayerIdle);
        image_speed = 0.2;
    }
    
    if (!onPlatform) // set jump/fall sprite
    {
        if (vspeed*sign(global.grav) &lt; -0.05) { playerSprite(sPlayerJump); }
        else if (vspeed*sign(global.grav) &gt; 0.05) { playerSprite(sPlayerFall); }
    }
    else // fall off platform
    {
        if (!place_meeting(x,y+4*sign(global.grav),oPlatform)) { onPlatform = false; }
    }
    
    // slide block
    var slideBlockTouchingH = instance_place(x, y + sign(global.grav), oSlideBlock);
    var slideBlockTouchingV = instance_place(x + global.player_xscale, y, oSlideBlock);
    
    if (slideBlockTouchingH != noone || slideBlockTouchingV != noone) //on a slide block, start moving with it
    {
        if (slideBlockTouchingH != noone) //moving horizontally (conveyor)
            hspeed += slideBlockTouchingH.h; 
            
        if (slideBlockTouchingV != noone) //moving vertically (elevator)
        {
            vspeed += slideBlockTouchingV.v;
            
            if (!place_meeting(x, y-(vspeed*global.grav),oBlock))
            {
                if (vspeed * sign(global.grav) &lt;= 0) { playerSprite(sPlayerJump); }
                else if (vspeed * sign(global.grav) &gt; 0) { playerSprite(sPlayerFall); }
            }
        }
    }
    
    // terminal velocity
    if (abs(vspeed) &gt; maxVspeed)
        vspeed = sign(vspeed)*maxVspeed;
    
    // jump, shoot, suicide
    if (!frozen)
    {
        if (scrButtonCheckPressed(KEY.JUMP))//|| (keyboard_check(ord("J")))
            playerJump();
        if (scrButtonCheckReleased(KEY.JUMP))//|| (keyboard_check(ord("K")))
            playerVJump();
    }
} 
else 
{
    if (!frozen) //Lunar Lander, aka "Rocket"
    {
        if (scrButtonCheckPressed(KEY.JUMP) &amp;&amp; global.vkid) { playerJump(); }
        
        if (start)
        { 
            //if (instance_exists(objBow)) { instance_destroy(objBow); } 
        }
    
        if ((gravity == 0) &amp;&amp; (L || (R || (U || D))))
        {
            start = true;
            gravity = 0.008;
        }
            
        image_angle = (image_angle + 360 + (L - R)) % 360;
        
        global.playerAngle = image_angle;
        playerSprite(sLunarkid);
    }
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT) &amp;&amp; !keyboard_check(vk_control))
        playerShoot();
    if (scrButtonCheckPressed(KEY.SUICIDE)) 
        killPlayer();
}

if (global.adjustTAS) 
    adjustPlayerPosition_EndStep();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ladders
if (!global.lunarkid)
{
    ladderV = false;
    ladderH = false;
    
    //var vertical = (scrButtonCheck(KEY.DOWN) - scrButtonCheck(KEY.UP))
    if (scrButtonCheck(KEY.UP) || scrButtonCheck(KEY.DOWN))
    {
        if (!onLadder &amp;&amp; place_meeting(x,y,oLadder))
        {
            onLadder = true;
            djump = numJumps-1;
        }
    }
    if (onLadder)
    {
        if (!place_meeting(x,y,oLadder))
            onLadder = false;
        else
        {
            if (scrButtonCheck(KEY.UP))
            {
                y -= maxSpeed;
                gravity = 0;
                vspeed = 0;
    
                ladderV = true;
                ladderH = false;
            }
            else if (scrButtonCheck(KEY.DOWN))
            {
                y += maxSpeed;
                gravity = 0;
                vspeed = 0;
    
                ladderV = true;
                ladderH = false;
            }
            
            if (scrButtonCheck(KEY.RIGHT))
            {
                x += maxSpeed;
                gravity = 0;
                hspeed = 0;
                
                ladderH = true;
                ladderV = false;
            }
            else if (scrButtonCheck(KEY.LEFT))
            {
                x -= maxSpeed;
                gravity = 0;
                hspeed = 0;
                    
                ladderH = true;
                ladderV = false;
            }
            
            if (scrButtonCheckPressed(KEY.JUMP))
            {
                ladderJump = true;
                onLadder = false;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vines
if (!global.lunarkid)
{
    if (onVineL || onVineR) 
    {
        //Jungle adventure vines
        var onRise = ((onVineR &amp;&amp; vineR.object_index == oRiseVineR) || (onVineL &amp;&amp; vineL.object_index == oRiseVineL)); 
        var onIce = ((onVineR &amp;&amp; vineR.object_index == oIceVineR) || (onVineL &amp;&amp; vineL.object_index == oIceVineL)); 
        var onFlip = ((onVineR &amp;&amp; vineR.object_index == oFlipVineR) || (onVineL &amp;&amp; vineL.object_index == oFlipVineL)); 
        var onSticky = ((onVineR &amp;&amp; vineR.object_index == oStickyVineR) || (onVineL &amp;&amp; vineL.object_index == oStickyVineL));
        var onLowGrav = ((onVineR &amp;&amp; vineR.object_index == oLowGravVineR) || (onVineL &amp;&amp; vineL.object_index == oLowGravVineL));
        //var onWhite = ((onVineR &amp;&amp; vineR.object_index == oTwinWhiteVineR) || (onVineL &amp;&amp; vineL.object_index == oTwinWhiteVineL));
        //var onBlack = ((onVineR &amp;&amp; vineR.object_index == oTwinBlackVineR) || (onVineL &amp;&amp; vineL.object_index == oTwinBlackVineL));
        var onFire = ((onVineR &amp;&amp; vineR.object_index == oFireVineR) || (onVineL &amp;&amp; vineL.object_index == oFireVineL));
        var onZeroGrav = ((onVineR &amp;&amp; vineR.object_index == oZeroGravVineR) || (onVineL &amp;&amp; vineL.object_index == oZeroGravVineL));
        var onAuto = ((onVineR &amp;&amp; vineR.object_index == oAutoVineR) || (onVineL &amp;&amp; vineL.object_index == oAutoVineL));
        var onReverse = ((onVineR &amp;&amp; vineR.object_index == oReverseVineR) || (onVineL &amp;&amp; vineL.object_index == oReverseVineL));
        
        if (onVineL) 
            global.player_xscale = -1;
        else 
            global.player_xscale = 1;
            
        if (!onIce) {
            if (onRise) {
                vspeed = -2*sign(global.grav); 
            } 
            else if (onSticky) { 
                vspeed = 0; 
                vineStick = true; 
            } 
            else { 
                vspeed = 2*sign(global.grav); 
            }
        }
        
        playerSprite(sPlayerSliding);
        image_speed = 0.5;
        
        // pressed away from the vine
        if (onVineR &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) || keyboard_check(ord('P'))
        || (onVineL &amp;&amp; scrButtonCheckPressed(KEY.LEFT)) || keyboard_check(ord('O')) 
        {       
            if (scrButtonCheck(KEY.JUMP)) // jumping off vine
            {
                if (onVineL) 
                    hspeed = -15;
                else 
                    hspeed = 15;
        
                if (onFlip) { flipGravity(0); }
                    
                vspeed = -9 * sign(global.grav);
                audio_play_sound(sndWallJump,0,0);
                playerSprite(sPlayerJump);
                
                /*if (onWhite || onBlack) { 
                    global.vineToggle = !global.vineToggle 
                }*/
            }
            else // walking off vine
            {
                if (onVineL) 
                    hspeed = -3;
                else 
                    hspeed = 3;
                    
                playerSprite(sPlayerFall);
            }
            
            if (onLowGrav) { 
                vineLowGrav = 1; 
            }
            if (onZeroGrav) {
                vineZeroGrav = 1;
            }
            if (onFire) { 
                maxSpeed = 6; 
                vineSpeed = 1; 
            }
            if (onAuto) {
                vineAuto = 1;
            }
        }
    }
    
    //Particles for low grav / fire vines
    /*if (vineLowGrav &amp;&amp; global.count mod 10 == 1) {
        part_particles_create(global.partsys_vine,x,y,global.vineLowGravPart,2); 
    }*/
    /*if (vineLowGrav &amp;&amp; global.count mod 7 == 1) {
        part_particles_create(global.vinesys_vine,x,y,global.vineZeroGravPart,2); 
    }*/
    if (vineSpeed &amp;&amp; global.count mod 3 == 1) {
        instance_create(x,y,oFireVinePart);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slopes 
if (!global.lunarkid)
{
    if (instance_exists(oSlope) &amp;&amp; hspeed != 0)
    {
        var moveLimit = abs(hspeed);   //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
        
        var slopeCheck;
        var hTest;
        
        var ySlope;
        
        //falling onto a slope
        if (place_meeting(x+hspeed, y+vspeed+gravity, oSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
        {
            var xLast = x;
            var yLast = y;
            var hLast = hspeed;
            var vLast = vspeed;
            
            vspeed += gravity;
            
            x += hspeed;
            hspeed = 0;
            
            if(!place_free(x, y+vspeed))
            {
                if (global.grav == 1)    //Normal
                    move_contact_solid(270, abs(vspeed));
                else    //Flipped
                    move_contact_solid(90, abs(vspeed));
                vspeed = 0;
            }
            
            y += vspeed;            
            
            if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
            {
                djump = 1;
                notOnBlock = false;
            }
            else    //Did not snap onto the slope, return to previous position
            {
                x = xLast;
                y = yLast;
                hspeed = hLast;
                vspeed = vLast;
            }
        }
        
        //Moving down a slope
        if (!notOnBlock)
        {                                              
            var onSlope = (place_meeting(x, y + global.grav, oSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
            
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                //Check how far we should move down
                while ((!place_meeting(x + hTest, y - ySlope + global.grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
                {
                    ySlope -= global.grav;
                }
                
                //Check if we actually need to move down
                if (place_meeting(x + hTest, y - ySlope + global.grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
                {
                    if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                    {
                        y -= ySlope;
                        
                        x += hTest;
                        hspeed = 0;
                        
                        slopeCheck = false;
                    }
                    else
                    {
                        if (hTest &gt; 0)
                        {
                            hTest -= 1;
                            if (hTest &lt;= 0)
                                slopeCheck = false;
                        }
                        else if (hTest &lt; 0)
                        {
                            hTest += 1;
                            if (hTest &gt;= 0)
                                slopeCheck = false;
                        }
                        else
                        {
                            slopeCheck = false;
                        }
                    }
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
        
        //Moving up a slope
        if (place_meeting(x + hspeed, y, oSlope))
        {                                           
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                
                //Check how far we have to move up
                while ( place_meeting(x + hTest, y - ySlope, oSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
                {
                    ySlope += global.grav;
                }                                                 
                
                //Check if we actually need to move up
                if (place_free(x + hTest, y - ySlope))
                {            
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
        }
        
        //Set xprevious/yprevious coordinates for future solid collisions
        xprevious = x;
        yprevious = y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Block collision (Keep this last)

vspeed += gravity;

if (!place_free(x + hspeed, y + vspeed))
{
    if (!global.lunarkid)
    {
        //Block collision moves push blocks back, so let's undo that
        /*with (objPushBlock) {
            x = xMoved;
            y = yMoved;
        }*/
    
        if (!place_free(x + hspeed, y) &amp;&amp; hspeed != 0)
        {
            var maxDist = abs(hspeed);
            var dir = 180 * (hspeed &lt; 0);
            move_contact_solid(dir, maxDist);
            
            hspeed = 0;
        }
         
        if (!place_free(x, y + vspeed) &amp;&amp; vspeed != 0)
        {
            //Reset vine variables
            if (vspeed &gt; 0 &amp;&amp; sign(global.grav) == 1) || (vspeed &lt; 0 &amp;&amp; sign(global.grav) == -1) {
                vineGrav = false;
                if (vineSpeed) {
                    maxSpeed = 3;
                    vineSpeed = false;
                }
            }
        
            var maxDist = abs(vspeed);
            var dir = 270 - 180 * (vspeed &lt; 0);
            move_contact_solid(dir, maxDist);
            
            if (dir == 180 + sign(global.grav) * 90)
                { djump = numJumps-1; }
            vspeed = 0;
        }
        
        if (!place_free(x + hspeed, y + vspeed))
        {
            //hspeed = 0;
            //Traditional behavior when resolving corner collision is to stop hspeed. When on a platform, this can cause horizontal stutter, so we stop vspeed instead.
            var p = instance_place(x, y+vspeed, oPlatform);
            if (!p || place_meeting(x, y, p))
            {
                hspeed = 0;
            }
            else
            {
                vspeed = 0;
            }
        }
    }
    else
        killPlayer();
}

xsafe = x + hspeed;
ysafe = y + vspeed;

vspeed -= gravity;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///platform collision
var pd = 2, py = 9, phy = 1, pyc = 8;

if (global.dotkid)
{
    if (global.dotplatfix) 
    { 
        pd = 1;
        py = 1;
        pyc = 0;
        phy = 1;
    }
}

if (global.lunarkid || !other.snap) 
    exit;

if (sign(global.grav == 1)) 
{
    if (y-vspeed/pd &lt;= other.y) // touching platform
    {
        if (other.vspeed &gt;= 0) // snap to platform
        {
            y = other.y-py;
            vspeed = other.vspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
else
{
    if (y-vspeed/pd &gt;= other.y+other.sprite_height-pyc) // touching platform
    {
        if (other.yspeed &lt;= 0) // snap to platform
        {
            y = other.y+other.sprite_height+phy;
            vspeed = other.yspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///unstuck algorithm
if (!place_free(x, y)) //If stuck, try to free myself
{
    var maxDist = 16; //How many pixels on each side did the sprite get wider by.
    for(var i = 0; i &lt;= maxDist; i+=1)
    {
        if (place_free(x+i,y))
        {
            x = x+i;
            break;
        }
        else if (place_free(x-i,y))
        {
            x = x-i;
            break;
        }
        
        if (place_free(x,y+i))
        {
            y = y+i;
            //show_debug_message("before: "+string(y)+"/"+"after: "+string(y+i))
            break;
        }
        else if (place_free(x,y-i))
        {
            y = y-i;
            //show_debug_message("before: "+string(y)+"/"+"after: "+string(y-i))
            break;
        }
    }
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw
/*if (global.grav == 1) {
    draw_sprite_ext(sprite_index,image_index,round(x),round(y),
    global.player_xscale,1,image_angle,image_blend,image_alpha)
}
else {
    //need to draw the player a pixel off when flipped for some reason
    draw_sprite_ext(sprite_index,image_index,round(x),round(y+1),
    global.player_xscale,-1,image_angle,image_blend,image_alpha)
}*/

var drawX = x, drawY = y, pCol = c_white;
var xScale = global.player_xscale;
var yScale = global.grav;
 
if (!global.vkid) 
{
    if (!global.infinitejump) 
    { 
        if (!global.dotkid) { pCol = c_white; }
        else 
        { 
            if (global.telekid) { pCol = c_white; }
            else { pCol = c_red; }
        }
    }
    else { pCol = c_blue; }
}
if (global.vkid = 1) { pCol = make_color_rgb(1,164,217); }
else if (global.vkid = 2) { pCol = make_color_rgb(164,1,171); }

if (!global.dotkid &amp;&amp; !global.linekid &amp;&amp; !global.lunarkid)
{
    if (global.grav == -1) { drawY += 1; }
    xScale = global.player_xscale;
    yScale = global.grav;
}
else
{
    xScale = image_xscale;
    yScale = image_yscale;
    
    if (global.showhitbox != 0)
        pCol = c_fuchsia;
}

if (global.showhitbox != 2) 
{
    if (!global.vkid &amp;&amp; !global.telekid) 
    {
        draw_sprite_ext(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha);
    } 
    else 
    {
        draw_sprite_fog(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha,pCol);
    }
}
if (global.showhitbox != 0) 
{
    draw_sprite_ext(mask_index,0,x,y,
    image_xscale,image_yscale,image_angle,pCol,(0.5*global.showhitbox));
}

if (mask_index = sDotkid &amp;&amp; global.dotkidoutline)
    draw_sprite_ext(sDotkidOutline,0,x,y,1,1,image_angle,pCol,1);

if (teled) { 
    var telex = 96 * global.player_xscale;
    draw_sprite_ext(mask_index, image_index, x+telex, y, global.player_xscale, sign(global.grav), image_angle, image_blend, 0.5);
}
    
if (hit &gt; 0)
    draw_sprite_ext(sPlayerHit,0,hitX,hitY,1,1,0,c_white,hit/floor(50/2));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
