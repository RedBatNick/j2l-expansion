<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sEditorKid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.tasAD = false;

jump = 8.5 * global.grav;
jump2 = 7 * global.grav;
maxSpeed = 3;
maxVspeed = 9;

if (global.linekid)
    image_angle = global.savePlayerAngle;

if (global.lunarkid) 
{
    //sl = instance_create(x, y, objBow);
    //sl.sprite_index = sprLander; 
    gravity = 0; 
    friction = 0.0005;
}
else { gravity = 0.4 * global.grav }

frozen = false;
numJumps = 2;
djump = numJumps-1;
onPlatform = false;
image_speed = 0.2;
nudgeBlockCheck = false;

slipSpeed = 0;
start = false;

hit = 0;
hitX = x;
hitY = y;

playerMask();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision
var killer = instance_place(x,y,oKiller);
if (killer != noone)
{
    killPlayer();
    with (killer) { highlight_count = 0; }
}

//Control how long the player is intangible after being hit while god mode is active
if (hit != 0) 
{ 
    image_alpha = 0.7;
    hit -= 1; 
}
else { image_alpha = 1; }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Edge of screen death

var xxL = x; 
var xxR = x; 
var yyU = y; 
var yyD = y;

switch(global.borderbox)
{
    case bboxtype_center:
    xxL = x;
    xxR = x;
    yyU = y;
    yyD = y;
    break;

    case bboxtype_far:
    xxL = bbox_right;
    xxR = bbox_left;
    yyU = bbox_bottom;
    yyD = bbox_top;
    break;
    
    case bboxtype_near:
    xxL = bbox_left;
    xxR = bbox_right;
    yyU = bbox_top;
    yyD = bbox_bottom;
    break;
}

if (xxL &lt; 0 || xxR &gt; 800)
{
    if (global.screenwraptype != wraptype_h &amp;&amp; global.screenwraptype != wraptype_both) 
    {
        if (global.deathEnabled) { killPlayer(); }
        if (xxL &lt; 0)
        {
            with (oBorderDeath)
            {
                if (type = "left")
                    highlight_count = 0;
            }
        }
        else if (xxR &gt; 800)
        {
            with (oBorderDeath)
            {
                if (type = "right")
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (xxL &lt; 0) { x += 800; }
        else if (xxR &gt; 800) { x -= 800; }
    }
}

if (yyU &lt; 0 || yyD &gt; 608)
{
    if (global.screenwraptype != wraptype_v &amp;&amp; global.screenwraptype != wraptype_both) 
    {
        if (global.deathEnabled) { killPlayer(); }
        
        if (yyU &lt; 0)
        {
            with (oBorderDeath) 
            {
                if (type = "top")
                    highlight_count = 0;
            }
        }
        else if (yyD &gt; 608)
        {
            with (oBorderDeath)
            {
                if (type = "bottom")
                    highlight_count = 0;
            }
        }
    } 
    else 
    {
        if (yyU &lt; 0) { y += 608; }
        else if (yyD &gt; 608) { y -= 608; }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.frameaction_jump = false;
global.frameaction_djump = false;
global.frameaction_jumpslow = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///record add list
if (global.record == 1) 
{
    //#1
    ds_list_add(global.recordList,scrButtonCheck(KEY.RIGHT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.LEFT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.UP));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.DOWN));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.RIGHT));
     
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.LEFT));
    
    ds_list_add(global.recordList,scrButtonCheck(KEY.JUMP));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.JUMP));
    
    ds_list_add(global.recordList,scrButtonCheckReleased(KEY.JUMP));
    
    //#2
    ds_list_add(global.recordList,keyboard_check(ord('J')));
    
    ds_list_add(global.recordList,keyboard_check(ord('K')));
    
    ds_list_add(global.recordList,keyboard_check(ord('P')));
    
    ds_list_add(global.recordList,keyboard_check(ord('O')));
    
    //#3
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.ALIGN_LEFT));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.ALIGN_RIGHT));
    
    ds_list_add(global.recordList,keyboard_check(ord('U')));
    
    ds_list_add(global.recordList,keyboard_check(ord('I')));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.NUDGE_LEFT));
    
    ds_list_add(global.recordList,scrButtonCheckPressed(KEY.NUDGE_RIGHT));

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player actions and movement
var L = scrButtonCheck(KEY.LEFT);//keyboard_check_direct(KEY.LEFT);
var R = scrButtonCheck(KEY.RIGHT);//keyboard_check_direct(KEY.RIGHT);
var U = scrButtonCheck(KEY.UP);
var D = scrButtonCheck(KEY.DOWN);


if (!global.recordingpaused &amp;&amp; !instance_exists(oRecordPlayer))
    global.PlayerFrameCounter += 1;

if (!global.lunarkid) 
{
    h = 0;
    
    // Check for block underneath for nudging.
    var notOnBlock = (place_free(x, y + global.grav));
    
    if (global.checkNudgeEarly)
        nudgeBlockCheck = place_meeting(x,y+global.grav,oBlock);
    else
        nudgeBlockCheck = false;
    
    //vine checks
    if (!global.linekid)
        xOff = 1;
    else
        xOff = 2;
    
    onVineL = (place_meeting(x-xOff,y,oVineL) &amp;&amp; notOnBlock);
    onVineR = (place_meeting(x+xOff,y,oVineR) &amp;&amp; notOnBlock);
        
    //gravity checks
    gravity = 0.4 * global.grav;
    
    //speed checks
    if (global.icetype == icetype_pressure)
        global.slippage = 0.07;
    else
        global.slippage = 0;
    
    if (global.icetype == icetype_domu) 
    {
        if (!instance_exists(oDomuIce))
            instance_create(x,y,oDomuIce);
    }
    else
    {
        if (instance_exists(oDomuIce))
            with (oDomuIce) { instance_destroy(); }
    }
    
    if (global.icetype == icetype_slip) { var block = oBlock; }
    else { var block = oSlipBlock; }
    
    with (block) { slip = 0.2; }
    var slipBlockTouching = instance_place(x,y+4*global.grav,block);
    
    if (global.linekid) //LineKid functionality
    {   
        image_angle = global.playerAngle;
    
        if ((scrButtonCheck(KEY.ALIGN_LEFT) || U) || (scrButtonCheck(KEY.ALIGN_RIGHT) || D))
        {
            if (scrButtonCheck(KEY.ALIGN_LEFT) || U)
            {
                if (((global.playerAngle &gt;= 0) &amp;&amp; (global.playerAngle &lt; 90)) || ((global.playerAngle &gt;= 180) &amp;&amp; (global.playerAngle &lt; 270)))
                {
                    if (place_free((x - 2), y) || place_free((x + 2), y))
                    {
                        global.playerAngle += 3;
                        
                        if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                        {
                            global.playerAngle = ((global.playerAngle + 360) % 360);
                        }
                    }
                }
                else if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                {
                    global.playerAngle += 3;
                    
                    if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                    {
                        global.playerAngle = ((global.playerAngle + 360) % 360);
                    }
                }
            }
            if (scrButtonCheck(KEY.ALIGN_RIGHT) || D)
            {
                if (((global.playerAngle &gt; 0) &amp;&amp; (global.playerAngle &lt;= 90)) || ((global.playerAngle &gt; 180) &amp;&amp; (global.playerAngle &lt;= 270)))
                {
                    if (place_free(x, (y - 2)) || place_free(x, (y + 2)))
                    {
                        global.playerAngle -= 3;
                        
                        if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                        {
                            global.playerAngle = ((global.playerAngle + 360) % 360);
                        }
                    }
                }
                else if (place_free((x - 2), y) || place_free((x + 2), y))
                {
                    global.playerAngle -= 3;
                    if ((global.playerAngle &gt; 360) || (global.playerAngle &lt; 0))
                    {
                        global.playerAngle = ((global.playerAngle + 360) % 360);
                    }
                }
            }
        }
        
        if (!notOnBlock)
        {
            if place_free(x, y)
            {
                testDist = 0;
                
                while (place_free(x, ((y + testDist) + 0.05)) &amp;&amp; (testDist &lt; 2))
                    testDist += 0.05;
                    
                if (testDist &lt; 2) { y += testDist; }
            }
        }
        
        firstMove = 0;
        lastMoveLast = 0;
        xBack = x; 
        yBack = y;
        
        blah = 0;
        if (true)//while ((!place_free(x, y)) || place_meeting(x, y, oBlock))
        {
            lastMove = 0;
            lineCollisionBlock = scrInstancePlaceList(x, y, oBlock);
            if (lineCollisionBlock != -4)
            {
                num = ds_list_size(lineCollisionBlock)
                for (i = 0; i &lt; num; i++)
                {
                    if (ds_list_find_value(lineCollisionBlock, i)).solid
                    {
                        testDistXpos = 0;
                        testDistYpos = 0;
                        testDistXneg = 0;
                        testDistYneg = 0;
                        
                        if (blah)
                        {
                            if (firstMove == 1) { testDistXpos = 99; }
                            else if (firstMove == 2) { testDistXneg = 99; }
                            else if (firstMove == 3) { testDistYpos = 99; }
                            else if (firstMove == 4) { testDistYneg = 99; }
                        }
                        
                        if (lastMove == 1) { testDistXneg = 99; }
                        else if (lastMove == 2) { testDistXpos = 99; }
                        else if (lastMove == 3) { testDistYneg = 99; }
                        else if (lastMove == 4) { testDistYpos = 99; }
                        
                        while (place_meeting((x + testDistXpos), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXpos &lt; 3))
                            testDistXpos += 0.2;
                            
                        while (place_meeting((x - testDistXneg), y, ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistXneg &lt; 3))
                            testDistXneg += 0.2;
                            
                        while (place_meeting(x, (y + testDistYpos), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYpos &lt; 3))
                            testDistYpos += 0.2;
                            
                        while (place_meeting(x, (y - testDistYneg), ds_list_find_value(lineCollisionBlock, i)) &amp;&amp; (testDistYneg &lt; 3))
                            testDistYneg += 0.2;
                            
                        move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                        
                        if (move &lt; 3)
                        {
                            if (move == testDistXpos)
                            {
                                x += testDistXpos; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 1; }
                                lastMoveLast = lastMove; lastMove = 1;
                            }
                            else if (move == testDistXneg)
                            {
                                x -= testDistXneg; xprevious = x;
                                
                                if (firstMove == 0) { firstMove = 2; }
                                lastMoveLast = lastMove; lastMove = 2;
                            }
                            else if (move == testDistYpos)
                            {
                                y += testDistYpos; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 3; }
                                lastMoveLast = lastMove; lastMove = 3;
                            }
                            else if (move == testDistYneg)
                            {
                                y -= testDistYneg; yprevious = y;
                                
                                if (firstMove == 0) { firstMove = 4; }
                                lastMoveLast = lastMove; lastMove = 4;
                            }
                        }
                        else
                        {
                            x = xBack; y = yBack;
                            yprevious = yBack; xprevious = xBack;
                            lastMove = lastMoveLast;
                        }
                    }
                }
                if (!place_free(x, y))
                {
                    testDistXpos = 0;
                    testDistYpos = 0;
                    testDistXneg = 0;
                    testDistYneg = 0;
                    
                    while ((!place_free((x + testDistXpos), y)) &amp;&amp; (testDistXpos &lt; 3))
                        testDistXpos += 0.2;
                        
                    while ((!place_free((x - testDistXneg), y)) &amp;&amp; (testDistXneg &lt; 3))
                        testDistXneg += 0.2;
                        
                    while ((!place_free(x, (y + testDistYpos))) &amp;&amp; (testDistYpos &lt; 3))
                        testDistYpos += 0.2;
                        
                    while ((!place_free(x, (y - testDistYneg))) &amp;&amp; (testDistYneg &lt; 3))
                        testDistYneg += 0.2;
                        
                    move = min(testDistXpos, testDistXneg, testDistYpos, testDistYneg);
                    
                    if (move == testDistXpos)
                    {
                        x += testDistXpos; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 1; }
                        lastMoveLast = lastMove; lastMove = 1;
                    }
                    else if (move == testDistXneg)
                    {
                        x -= testDistXneg; xprevious = x;
                        
                        if (firstMove == 0) { firstMove = 2; }
                        lastMoveLast = lastMove; lastMove = 2;
                    }
                    else if (move == testDistYpos)
                    {
                        y += testDistYpos; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 3; }
                        lastMoveLast = lastMove; lastMove = 3;
                    }
                    else if (move == testDistYneg)
                    {
                        y -= testDistYneg; yprevious = y;
                        
                        if (firstMove == 0) { firstMove = 4; }
                        lastMoveLast = lastMove; lastMove = 4;
                    }
                }
            }
            blah = 1;
        }
    }
    else
    {
        if (!global.lunarkid)
        {
            if (image_angle != 0) { image_angle = 0; }
        }
    }
    
    // moving
    var h = R;
    if (h == 0) { h = -L; }
    if (frozen) { h = 0; }
    
    if (h != 0) 
    {
        if (!onVineR &amp;&amp; !onVineL)
            global.player_xscale = h;

        if (h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL) 
        {
            if (global.slippage != 0)   //player momentum, aka "CBT Ice"
            {
                hspeed += global.slippage * h;
                    
                if (abs(hspeed) &gt; maxSpeed)
                    hspeed = maxSpeed * h;
            }
            else if (slipBlockTouching == noone) 
            {
                hspeed = maxSpeed * h;
            }
            else 
            {
                if (h == 1 &amp;&amp; hspeed &lt; maxSpeed) || (h == -1 &amp;&amp; hspeed &gt; -maxSpeed) 
                    hspeed += slipBlockTouching.slip * h;
            }
            playerSprite(sPlayerRunning);
            image_speed = 0.5;
        }
    }
    else // not moving
    {
        if (global.slippage != 0)
        {
            if (abs(hspeed) &gt; maxSpeed) { hspeed = maxSpeed * ((hspeed)); }
            if (hspeed &gt; 0)
            {
                hspeed -= (global.slippage / 2);
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0)
            {
                hspeed += (global.slippage / 2);
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        else if (slipBlockTouching == noone) 
        {
            hspeed = 0;
        }
        else 
        {
            if (hspeed &gt; 0) 
            {
                hspeed -= slipBlockTouching.slip;
                if (hspeed &lt;= 0) { hspeed = 0; }
            }
            else if (hspeed &lt; 0) 
            {
                hspeed += slipBlockTouching.slip;
                if (hspeed &gt;= 0) { hspeed = 0; }
            }
        }
        playerSprite(sPlayerIdle);
        image_speed = 0.2;
    }
    
    if (!onPlatform) // set jump/fall sprite
    {
        if (vspeed*sign(global.grav) &lt; -0.05) { playerSprite(sPlayerJump); }
        else if (vspeed*sign(global.grav) &gt; 0.05) { playerSprite(sPlayerFall); }
    }
    else // fall off platform
    {
        if (!place_meeting(x,y+4*sign(global.grav),oPlatform)) { onPlatform = false; }
    }
    
    // slide block
    var slideBlockTouchingH = instance_place(x, y + sign(global.grav), oSlideBlock);
    var slideBlockTouchingV = instance_place(x + global.player_xscale, y, oSlideBlock);
    
    if (slideBlockTouchingH != noone || slideBlockTouchingV != noone) //on a slide block, start moving with it
    {
        if (slideBlockTouchingH != noone) //moving horizontally (conveyor)
            hspeed += slideBlockTouchingH.h; 
            
        if (slideBlockTouchingV != noone) //moving vertically (elevator)
        {
            vspeed += slideBlockTouchingV.v;
            
            if (!place_meeting(x, y-(vspeed*global.grav),oBlock))
            {
                if (vspeed * sign(global.grav) &lt;= 0) { playerSprite(sPlayerJump); }
                else if (vspeed * sign(global.grav) &gt; 0) { playerSprite(sPlayerFall); }
            }
        }
    }
    
    // terminal velocity
    if (abs(vspeed) &gt; maxVspeed)
        vspeed = sign(vspeed)*maxVspeed;
    
    // jump, shoot, suicide
    if (!frozen)
    {
        if (scrButtonCheckPressed(KEY.JUMP))
            playerJump();
        if (scrButtonCheckReleased(KEY.JUMP))
            playerVJump();

        /*if (keyboard_check(ord("J")))
        {
            global.tasAD = true;
            playerJump();
        }
        if (keyboard_check(ord("K"))) 
            playerVJump();*/
    }
} 
else 
{
    if (!frozen) //Lunar Lander, aka "Rocket"
    {
        if (scrButtonCheckPressed(KEY.JUMP) &amp;&amp; global.vkid) { playerJump(); }
        
        if (start)
        { 
            //if (instance_exists(objBow)) { instance_destroy(objBow); } 
        }
    
        if ((gravity == 0) &amp;&amp; (L || (R || (U || D))))
        {
            start = true;
            gravity = 0.008;
        }
        
        if (U) { motion_add((image_angle + 90), 0.013); }
        if (L) { image_angle += 1; }
        else if (R) { image_angle -= 1; }
         
        if (image_angle &gt; 360 || image_angle &lt; 0)
            image_angle = ((image_angle + 360) % 360);
        
        global.playerAngle = image_angle;
        playerSprite(sLunarkid);
    }
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT) &amp;&amp; !keyboard_check(vk_control))
        playerShoot();
    if (scrButtonCheckPressed(KEY.SUICIDE)) 
        killPlayer();
}

if (global.adjustTAS) 
    adjustPlayerPosition_EndStep();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vines

if (!global.linekid)
    var xOff = 1;
else
    var xOff = 2;
    
var onVineL = (place_meeting(x-xOff,y,oVineL))// &amp;&amp; notOnBlock);
var onVineR = (place_meeting(x+xOff,y,oVineR))// &amp;&amp; notOnBlock);

if (onVineL || onVineR) 
{
    if (onVineR) 
        global.player_xscale = -1;
    else 
        global.player_xscale = 1;
        
    vspeed = 2*global.grav;
    
    playerSprite(sPlayerSliding);
    image_speed = 0.5;
    
    // pressed away from the vine
    if (onVineL &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) // || scrButtonCheck(ord('P'))
    or (onVineR &amp;&amp; scrButtonCheckPressed(KEY.LEFT)) // || scrButtonCheck(ord('O')) 
    {       
        if (scrButtonCheck(KEY.JUMP)) // jumping off vine
        {
            if (onVineR) 
                hspeed = -15;
            else 
                hspeed = 15;
    
            vspeed = -9 * global.grav;
            
            audio_play_sound(sndWallJump,0,0);
            playerSprite(sPlayerJump);
        }
        else // walking off vine
        {
            if (onVineR) 
                hspeed = -3;
            else 
                hspeed = 3;
                
            playerSprite(sPlayerFall);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///slopes 

if (instance_exists(oSlope) &amp;&amp; hspeed != 0)
{
    var moveLimit = abs(hspeed);   //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed, y+vspeed+gravity, oSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x, y+vspeed))
        {
            if (global.grav == 1)    //Normal
                move_contact_solid(270, abs(vspeed));
            else    //Flipped
                move_contact_solid(90, abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //Did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //Moving down a slope
    if (!notOnBlock)
    {                                              
        var onSlope = (place_meeting(x, y + global.grav, oSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //Check how far we should move down
            while ((!place_meeting(x + hTest, y - ySlope + global.grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
            {
                ySlope -= global.grav;
            }
            
            //Check if we actually need to move down
            if (place_meeting(x + hTest, y - ySlope + global.grav, oSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
            {
                if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //Moving up a slope
    if (place_meeting(x + hspeed, y, oSlope))
    {                                           
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //Check how far we have to move up
            while ( place_meeting(x + hTest, y - ySlope, oSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
            {
                ySlope += global.grav;
            }                                                 
            
            //Check if we actually need to move up
            if (place_free(x + hTest, y - ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //Set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}                 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var pd = 2, py = 9, phy = 1, pyc = 8;

if (global.dotkid)
{
    if (global.dotplatfix) 
    { 
        pd = 1;
        py = 1;
        pyc = 0;
        phy = 1;
    }
}

if (global.lunarkid || !other.snap) 
    exit;

if (sign(global.grav == 1)) 
{
    if (y-vspeed/pd &lt;= other.y) // touching platform
    {
        if (other.vspeed &gt;= 0) // snap to platform
        {
            y = other.y-py;
            vspeed = other.vspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
else
{
    if (y-vspeed/pd &gt;= other.y+other.sprite_height-pyc) // touching platform
    {
        if (other.yspeed &lt;= 0) // snap to platform
        {
            y = other.y+other.sprite_height+phy;
            vspeed = other.yspeed;
        }
        if (other.object_index != oDisappearPlatform)
            onPlatform = true;
        
        djump = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// push against blocks horizontally
if (!global.lunarkid)
{
    if (!place_free(x+hspeed,y)) 
    {
        if (sign(global.grav) == 1) 
        {
            var dir;
            if (hspeed &lt;= 0) { dir = 180; }
            if (hspeed &gt; 0) { dir = 0; }
            move_contact_solid(dir, abs(hspeed));
        }
        else if (sign(global.grav) == -1)
        {
            var dir;
            if (hspeed &lt; 0) { dir = 180; }
            if (hspeed &gt;= 0) { dir = 0; }
            move_contact_solid(dir, abs(hspeed));
        }
        hspeed = 0;
    }
    
    // push against blocks vertically
    if (!place_free(x,y+vspeed))
    {
        if (sign(global.grav) == 1) 
        {
            var dir;
            if (vspeed &lt;= 0) { dir = 90; }
            if (vspeed &gt; 0) { dir = 270; djump = true; }
            move_contact_solid(dir, abs(vspeed));
        }
        else if (sign(global.grav) == -1)
        {
            var dir;
            if (vspeed &lt;= 0) { dir = 90; djump = true; }
            if (vspeed &gt; 0) { dir = 270; }
            move_contact_solid(dir, abs(vspeed));
        }
        vspeed = 0;
    }
    
    if (!place_free(x+hspeed,y+vspeed))
        hspeed = 0;
} 
else 
{
    killPlayer();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!place_free(x, y)) //If stuck, try to free myself
{
    var maxDist = 16; //How many pixels on each side did the sprite get wider by.
    for(var i = 0; i &lt;= maxDist; i+=1)
    {
        if (place_free(x+i,y))
        {
            x = x+i;
            break;
        }
        else if (place_free(x-i,y))
        {
            x = x-i;
            break;
        }
        
        if (place_free(x,y+i))
        {
            y = y+i;
            //show_debug_message("before: "+string(y)+"/"+"after: "+string(y+i))
            break;
        }
        else if (place_free(x,y-i))
        {
            y = y-i;
            //show_debug_message("before: "+string(y)+"/"+"after: "+string(y-i))
            break;
        }
    }
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if (global.grav == 1) {
    draw_sprite_ext(sprite_index,image_index,round(x),round(y),
    global.player_xscale,1,image_angle,image_blend,image_alpha)
}
else {
    //need to draw the player a pixel off when flipped for some reason
    draw_sprite_ext(sprite_index,image_index,round(x),round(y+1),
    global.player_xscale,-1,image_angle,image_blend,image_alpha)
}*/

var drawX = x, drawY = y, pCol = c_white;
var xScale = global.player_xscale;
var yScale = global.grav;
 
if (!global.vkid) 
{
    if (!global.infinitejump) 
    { 
        if (!global.dotkid) { pCol = c_white; }
        else 
        { 
            if (global.telekid) { pCol = c_white; }
            else { pCol = c_red; }
        }
    }
    else { pCol = c_blue; }
}
if (global.vkid = 1) { pCol = make_color_rgb(1,164,217); }
else if (global.vkid = 2) { pCol = make_color_rgb(164,1,171); }

if (!global.dotkid &amp;&amp; !global.linekid &amp;&amp; !global.lunarkid)
{
    if (global.grav == -1) { drawY += 1; }
    xScale = global.player_xscale;
    yScale = global.grav;
}
else
{
    xScale = image_xscale;
    yScale = image_yscale;
    
    if (global.showhitbox != 0)
        pCol = c_fuchsia;
}

if (global.showhitbox != 2) 
{
    if (!global.vkid &amp;&amp; !global.telekid) 
    {
        draw_sprite_ext(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha);
    } 
    else 
    {
        draw_sprite_fog(sprite_index,image_index,drawX,drawY,
        xScale,yScale,image_angle,pCol,image_alpha,pCol);
    }
}
if (global.showhitbox != 0) 
{
    draw_sprite_ext(mask_index,0,x,y,
    image_xscale,image_yscale,image_angle,pCol,(0.5*global.showhitbox));
}

if (mask_index = sDotkid &amp;&amp; global.dotkidoutline)
    draw_sprite_ext(sDotkidOutline,0,x,y,1,1,image_angle,pCol,1);

if (hit &gt; 0)
    draw_sprite_ext(sPlayerHit,0,hitX,hitY,1,1,0,c_white,hit/floor(50/2));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
